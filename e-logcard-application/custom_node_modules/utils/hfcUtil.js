let hfc = require('hfc');
let config = require('config');
let path = require('path');
const nodeUtil = require('util');
let chainDbManager=require('../database/chain-manager.js');
let hfcDbKeystore=require('../database/hfcDbKeystore.js');

const ATTRS = ['username', 'role'];
const StringDecoder = require('string_decoder').StringDecoder;

let chain;

exports.initializeContext = function (){
	var chainConfig=config.get("chain");
	var chainName=chainConfig.name;
	console.log("Debut initialisation de la chain "+chainName);
	chain = hfc.newChain(chainName);
	
	//This is the location of the key store HFC will use. If running locally, this directory must exist on your machine
	let hfcConfig=config.get("hfc");
	let keyStoreLocation=hfcConfig.keyStoreLocation;
	//chain.setKeyValStore(hfc.newFileKeyValStore(path.join(__dirname,keyStoreLocation)));
	chain.setKeyValStore(hfcDbKeystore.newHfcDbKeystore());
	
	registerHyperLedgerTenant(chain,hfcConfig);
	return new Promise(function(resolve, reject) {
		enrollAdminUser(chain,function(err, registrar) {
			if (!err) {
				console.log('INFO: Startup -> Admin user Logcard registration succeed');
				chain.setRegistrar(registrar);
				
				deployChaincode(registrar).then(function(chainRegistered){
					
					chain.uuid=chainRegistered.uuid;
					console.log("Fin initialisation de la chain "+chainName+" uuid =>"+chain.uuid);
					resolve(registrar);
					
				});
			} else {
				console.error('ERROR: Startup -> Failed to enroll Logcard registrar with admin '+nodeUtil.inspect(err));
				reject(err);
			}
		});
		
	});
};


let enrollUser=function (username,role) {
	//on build l utilisateur
	let logcardUser={
			"enrollmentID": username,
			"attributes": [
						{"name": "role", "value": role},
						{"name": "username", "value": username},
						/*{"name": "company", "value": "cap_gemini"},
						{"name": "allowed_handlers", "value": "Clearing_House_A"}*/
			],
		/*"registrar": {},*/
		"roles": [role],
		"affiliation": "bank_a"
	};
	
	
    return new Promise(function(resolve, reject) {
    	logcardUser.registrar = chain.getRegistrar();
        chain.registerAndEnroll(logcardUser, function(err, enrolledUser) {
            if (!err){
                // Successfully enrolled registrar and set this user as the chain's registrar which is authorized to register other users.
                console.log('INFO: Startup -> Registrar enroll worked with user '+enrolledUser.enrollmentID);
                resolve(enrolledUser);
            }
            else{
                console.error('ERROR: Startup -> Failed to enroll '+logcardUser.enrollmentID+' using HFC. Error: '+JSON.stringify(err));
                reject(err);
            }
        });
    });
};
exports.enrollUser=enrollUser;

function registerHyperLedgerTenant(chain,hfcConfig){
	console.log("Hyper ledger Registration starting");
	let hfcProtocol=hfcConfig.protocol;
	let hyperLedgerConfig=config.get("hyperledger");
	registerPeer(chain,hyperLedgerConfig,hfcProtocol);
	registerMemberService(chain,hyperLedgerConfig,hfcProtocol);
	console.log("Hyper ledger Registration ending");
}

function registerPeer(chain,hyperLedgerConfig,protocol){
	console.log("Peer Registration ");
	let peers = hyperLedgerConfig.peers;
	 peers.forEach(function(peer, index) {
        chain.addPeer(protocol+'://'+peer.discovery_host+':'+peer.discovery_port);
        console.log('INFO: Startup -> peer'+index+': '+protocol+'://'+peer.discovery_host+':'+peer.discovery_port);
    });
}
function registerMemberService(chain,hyperLedgerConfig,protocol){
	console.log("MemberService Registration ");
	let memberService = hyperLedgerConfig.memberService;
	chain.setMemberServicesUrl(protocol+'://'+memberService.discovery_host+':'+memberService.discovery_port);
	console.log('INFO: Startup -> membersrvc: '+protocol+'://'+memberService.discovery_host+':'+memberService.discovery_port);
}

function enrollAdminUser(chain,callback){
	console.log("Admin user Registration");
	let adminUser=config.get("admin");
	chain.enroll(adminUser.username, adminUser.password,callback);
}


function deployChaincode(adminSecurityContext) {
	let chainConfig=config.get("chain");
	let chaincodePath=chainConfig.path;
	let startMethod=chainConfig.initMethod;
	let certPath = chainConfig.certPath;
	
	let deployPath = '../../chaincode';

	process.env.GOPATH = path.resolve(path.join(__dirname, deployPath));
	console.log('INFO: App -> Go path: ', path.resolve(path.join(__dirname, deployPath)));

	
    return new Promise(function(resolve, reject) {
        //let enrolledUser = memberFromSC.getEnrolledMember();
	
		var chainName=chainConfig.name;
	
		chainDbManager.findChain(chainName,function(chain){
			if(chain){
				console.log("chain already exists");
				resolve(chain);
			}
			else{
				let deployRequest = {
					fcn: startMethod,
					args: [],
					chaincodePath: chaincodePath
				};
				deployRequest.certificatePath = certPath;

				let transactionContext = adminSecurityContext.deploy(deployRequest);

				transactionContext.on('submitted', function(result) {
					console.log('INFO: Startup -> Attempted to deploy chaincode');
				});

				transactionContext.on('complete', function (result) {
					console.log('INFO: Startup -> Chaincode deployed with chaincodeID ' + result.chaincodeID);
					console.log('INFO: Startup -> result :');
			
					result.name=chainName;
					chainDbManager.saveChainInformations(result,function(succeed){
						resolve(result);
					});
            
				});

				transactionContext.on('error', function (error) {
					console.error('ERROR: Startup -> Attempted to deploy chaincode with error:['+JSON.stringify(error)+']');
					if (error instanceof hfc.EventTransactionError) {
						reject(new Error(error.msg));
					} else {
						reject(error);
					}
				});
			}
		});
		
        
    });
}

exports.queryChaincode=function(enrolledUser, functionName, args) {
    try {
        if (!enrolledUser) {
            throw new Error('enrolledUser not provided');
        }  else if (!functionName) {
            throw new Error('functionName not provided');
        } else if (!args) {
            throw new Error('args not provided');
        }

        return new Promise(function(resolve, reject) {
            args.forEach(function(arg) {
                if (typeof arg !== 'string') {
                    throw new Error('Invalid arg specified ' + arg + ' in ', JSON.stringify(args));
                }
            });


            let query = {
                chaincodeID: chain.uuid,
                fcn: functionName,
                args: args,
                attrs: ATTRS
            };
            console.log('INFO: Util -> [#] Query: ', JSON.stringify(query));

            let tx = enrolledUser.query(query);

            tx.on('submitted', function() {
                console.log('INFO: Util -> QUERY -> SUBMITTED');
            });

            tx.on('complete', function(data) {
                let decoder = new StringDecoder('utf8');
                console.log('INFO: Util -> QUERY -> COMPLETE full data:');
                console.log(data);
                console.log('INFO: Util -> QUERY -> decode data:');
                console.log(decoder.write(data.result));
                console.log('INFO: Util -> QUERY -> Unit8Array data:');
                console.log('[' + new Uint8Array(data.result) + ']');
                resolve(decoder.write(data.result));
            });

            tx.on('error', function (err) {
                console.warn('ERROR: Util -> QUERY -> Attempted to query chaincode with error: ['+JSON.stringify(err)+']');
                if (err instanceof hfc.EventTransactionError) {
                    reject(new Error(err.msg));
                } else {
                    reject(err);
                }
            });
        });

    } catch(e) {
        console.error('ERROR: Util ->  QUERY -> CATCH', e);
    }
};


exports.invokeChaincode=function(enrolledUser, functionName, args) {
    try {
        if (!enrolledUser) {
            throw new Error('enrolledUser not provided');
        } else if (!functionName) {
            throw new Error('functionName not provided');
        } else if (!args) {
            throw new Error('args not provided');
        }

        return new Promise(function(resolve, reject) {
            args.forEach(function(arg) {
                if (typeof arg !== 'string') {
                    throw new Error('Invalid arg specified ' + arg + ' in ', args);
                }
            });


            let invoke = {
                chaincodeID: chain.uuid,
                fcn: functionName,
                args: args,
                attrs: ATTRS
            };

            console.log('INFO: Util -> [#] Invoke: ', JSON.stringify(invoke));

            let tx = enrolledUser.invoke(invoke);

            tx.on('submitted', function(data) {
                console.log('INFO: Util -> INVOKE -> SUBMITTED');
            });

            tx.on('complete', function(data) {
                let decoder = new StringDecoder('utf8');
                console.log('INFO: Util -> INVOKE -> COMPLETE full data:');
                console.log(data);
                console.log('INFO: Util -> INVOKE -> decode data:');
                console.log(decoder.write(data.result));
                console.log('INFO: Util -> INVOKE -> Unit8Array data:');
                console.log('[' + new Uint8Array(data.result) + ']');
                resolve(data.result);
            });

            tx.on('error', function (err) {
                console.warn('ERROR: Util ->  INVOKE -> Attempted to invoke chaincode with error: ['+JSON.stringify(err)+']');
                if (err instanceof hfc.EventTransactionError) {
                    reject(new Error(err.msg));
                } else {
                    reject(err);
                }
            });
        });
    } catch (e) {
        console.error('ERROR: Util ->  INVOKE -> CATCH '+ e);
    }
};




